<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-qmf.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-qmf.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-qmf.png">
  <link rel="mask-icon" href="/images/logo-qmf.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"midoq.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"buttons","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C&#x2F;C++的一众输入输出函数的区别常常搞得人晕头转向，二者之中又以输入函数更加令人头疼。本文尝试整理C&#x2F;C++的各种输入输出函数。 由于输入涉及空格、换行符的读取、忽略等问题，因此输入比输出更麻烦。所以本文将以输入为主线，对应的输出用法是类似的。 水平有限，如有疏漏，欢迎提出。">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++标准输入输出函数终极最全解析（不全捶我）">
<meta property="og:url" content="https://midoq.github.io/2022/02/27/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%BB%88%E6%9E%81%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%85%A8%E6%8D%B6%E6%88%91%EF%BC%89/index.html">
<meta property="og:site_name" content="TARDIS">
<meta property="og:description" content="C&#x2F;C++的一众输入输出函数的区别常常搞得人晕头转向，二者之中又以输入函数更加令人头疼。本文尝试整理C&#x2F;C++的各种输入输出函数。 由于输入涉及空格、换行符的读取、忽略等问题，因此输入比输出更麻烦。所以本文将以输入为主线，对应的输出用法是类似的。 水平有限，如有疏漏，欢迎提出。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-27T06:55:32.000Z">
<meta property="article:modified_time" content="2023-01-29T04:02:33.000Z">
<meta property="article:author" content="MidoQ">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://midoq.github.io/2022/02/27/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%BB%88%E6%9E%81%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%85%A8%E6%8D%B6%E6%88%91%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C/C++标准输入输出函数终极最全解析（不全捶我） | TARDIS</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TARDIS</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知识时光机</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>博客首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签集合</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>文章分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间线旅行</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://midoq.github.io/2022/02/27/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%BB%88%E6%9E%81%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%85%A8%E6%8D%B6%E6%88%91%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-qmf.png">
      <meta itemprop="name" content="MidoQ">
      <meta itemprop="description" content="钱缪峰的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TARDIS">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C/C++标准输入输出函数终极最全解析（不全捶我）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-02-27 14:55:32" itemprop="dateCreated datePublished" datetime="2022-02-27T14:55:32+08:00">2022-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/02/27/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%BB%88%E6%9E%81%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%85%A8%E6%8D%B6%E6%88%91%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/02/27/C%E5%92%8CC++%E4%B8%AD%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%BB%88%E6%9E%81%E6%9C%80%E5%85%A8%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%8D%E5%85%A8%E6%8D%B6%E6%88%91%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>C&#x2F;C++的一众输入输出函数的区别常常搞得人晕头转向，二者之中又以输入函数更加令人头疼。本文尝试整理C&#x2F;C++的各种输入输出函数。</p>
<p>由于输入涉及空格、换行符的读取、忽略等问题，因此输入比输出更麻烦。所以本文将以输入为主线，对应的输出用法是类似的。</p>
<p>水平有限，如有疏漏，欢迎提出。</p>
<span id="more"></span>

<h2 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h2><h3 id="C-标准输入"><a href="#C-标准输入" class="headerlink" title="C 标准输入"></a>C 标准输入</h3><p>C语言使用标准输入输出函数，需要包含头文件<code>&lt;stdio.h&gt;</code>。而在 C++ 中，只要包含头文件<code>&lt;iostream&gt;</code>，就完全可以使用这些 C 中的输入输出函数。</p>
<h4 id="标准输入流及对缓冲区的理解"><a href="#标准输入流及对缓冲区的理解" class="headerlink" title="标准输入流及对缓冲区的理解"></a>标准输入流及对缓冲区的理解</h4><p><code>stdin</code>是一个文件描述符（Linux）或句柄（Windows），它在 C 程序启动时就被默认分配好。在 Linux 中一切皆文件，<code>stdin</code>也相当于一个可读文件，它对应着键盘设备的输入。因为它不断地被输入，又不断地被读取，像流水一样，因此通常称作<strong>输入流</strong>。</p>
<p><code>stdin</code>是一种<strong>行缓冲</strong>I&#x2F;O。当在键盘上键入字符时，它们首先被存放在键盘设备自身的缓存中（属于<strong>键盘硬件设备</strong>的一部分）。只有输入换行符时，操作系统才会进行同步，将键盘缓存中的数据读入到<code>stdin</code>的输入缓冲区（存在于<strong>内存</strong>中）。所有从<code>stdin</code>读取数据的输入流，都是从<strong>内存中的</strong>输入缓冲区读入数据。当输入缓冲区为空时，函数将被阻塞。</p>
<p>若无特殊说明，以下所有的<strong>“缓冲区”</strong>均是指内存中的<code>stdin</code>输入缓冲区。用户程序中自定义的<code>buffer</code>数组、<code>str</code>数组等，将称作“数组”、“变量”，以免产生混淆。</p>
<h4 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h4><p>按照特定格式从<code>stdin</code>读取输入。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, str, &amp;a);    <span class="comment">// 注意，传入的一定是变量的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>对空白字符的处理：</strong></p>
<ol>
<li>缓冲区开头：丢弃空白字符（包括空格、Tab、换行符），直到第一个非空白字符才认为是第一个数据的开始。</li>
<li>缓冲区中间：开始读取第一个数据后，一旦<strong>遇到空白字符（非换行符）</strong>， 就认为<strong>读取完毕</strong>一次。遇到的<strong>空白字符残留在缓冲区</strong>，直到下一次被读取或刷新。例如输入字符串<code>this is test</code>，则会被认为是<code>3</code>个字符串。</li>
<li>缓冲区末尾：按下回车键时，<strong>换行符<code>\n</code>残留</strong>在缓冲区。换行符之前的空格可以认为是中间的空白字符，处理同上。</li>
</ol>
<p>注意，格式控制符只会读取正确类型的变量。如果输入格式不正确，比如在<code>%d</code>处输入了一个字符<code>a</code>，则会使读取中断，即后续不读取任何变量。</p>
<p><strong>格式控制符说明：</strong></p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">类型输入</th>
<th align="left">参数的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%d</td>
<td align="left">十进制整数</td>
<td align="left">int *</td>
</tr>
<tr>
<td align="left">%u</td>
<td align="left">无符号十进制整数</td>
<td align="left">unsigned int *</td>
</tr>
<tr>
<td align="left">%o</td>
<td align="left">八进制整数</td>
<td align="left">int *</td>
</tr>
<tr>
<td align="left">%x</td>
<td align="left">十六进制整数</td>
<td align="left">int *</td>
</tr>
<tr>
<td align="left">%f、%e、%g</td>
<td align="left">浮点数</td>
<td align="left">float *</td>
</tr>
<tr>
<td align="left">%lf、%le、%lg</td>
<td align="left">双精度浮点数</td>
<td align="left">double *</td>
</tr>
<tr>
<td align="left">%c</td>
<td align="left">单个字符（含空白字符）</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">%s</td>
<td align="left">字符串</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">%%</td>
<td align="left">读 % 符号</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注意，<code>%c</code>是一个比较特殊的格式符号，它将会读取所有空白字符，包括缓冲区开头的空格、Tab、换行符，使用时要特别注意。</p>
<p><code>scanf()</code>的读取也没有边界，所以并不安全。C11 标准提供了安全输入<code>scanf_s()</code>。</p>
<p><code>scanf()</code>对应的输出函数是<code>printf()</code>。</p>
<h4 id="gets-不建议"><a href="#gets-不建议" class="headerlink" title="gets() - 不建议"></a>gets() - 不建议</h4><p>按下回车键时，从<code>stdin</code>读取一行。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">gets(str);</span><br></pre></td></tr></table></figure>

<p><strong>对空白字符的处理：</strong></p>
<ol>
<li>所有空格、Tab等空白字符均被读取，不忽略。</li>
<li>按下回车键时，缓冲区末尾的换行符被丢弃，字符串末尾没有换行符<code>\n</code>，缓冲区也没有残留的换行符<code>\n</code>。</li>
</ol>
<p>注意，<code>gets()</code>不能指定读取上限，因此容易发生数组边界溢出，造成内存不安全。C11 使用了<code>gets_s()</code>代替<code>gets()</code>，但有时编译器未必支持，因此总体来说<strong>不建议</strong>使用<code>gets()</code>函数来读取输入。</p>
<p><code>gets()</code>对应的输出函数是<code>puts()</code>。</p>
<h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>从指定输入流读取一行，输入可以是<code>stdin</code>，也可以是文件流，使用时需要显式指定。</p>
<p><strong>读取文件流示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;...test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File open Error!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (fgets(str, <span class="keyword">sizeof</span>(str), fp) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;line%d [len %d]: %s&quot;</span>, i++, <span class="built_in">strlen</span>(str), str);</span><br><span class="line"> </span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>

<p><strong>读取stdin示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (fgets(str, <span class="keyword">sizeof</span>(str), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;line%d [len %d]: %s&quot;</span>, i++, <span class="built_in">strlen</span>(str), str);</span><br></pre></td></tr></table></figure>

<p><strong>对空白字符的处理：</strong></p>
<ol>
<li>所有空格、Tab等空白字符均被读取，不忽略。</li>
<li>按下回车键时，缓冲区末尾的换行符也被读取，字符串末尾将有一个换行符<code>\n</code>。例如，输入字符串<code>hello</code>，再按下回车，则读到的字符串长度为<code>6</code>。</li>
</ol>
<p><code>fgets()</code>函数会自动在字符串末尾加上<code>\0</code>结束符。</p>
<p>第 2 个参数<code>n</code>指定了读取的最大长度。函数读到<code>n-1</code>个字符（包括换行符<code>\n</code>）就会停止，并在末尾加上<code>\0</code>结束符。剩余字符将残留在缓冲区。</p>
<p>建议使用<code>fgets()</code>完全替代<code>gets()</code>。</p>
<p><code>fgets()</code>对应的输出函数是<code>fputs()</code>。</p>
<h4 id="fgetc-amp-getc"><a href="#fgetc-amp-getc" class="headerlink" title="fgetc() &amp; getc()"></a>fgetc() &amp; getc()</h4><p>从指定输入流读取一个字符，输入可以是<code>stdin</code>，也可以是文件流，使用时需要显式指定。</p>
<p>这两个函数完全等效，<code>getc()</code>由<code>fgetc()</code>宏定义而来。不同的是，前述的<code>gets()</code>和<code>fgets()</code>相互之间没有关系。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a, b;</span><br><span class="line">a = fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">b = getc(<span class="built_in">stdin</span>);</span><br></pre></td></tr></table></figure>

<p><strong>对空白字符的处理：</strong></p>
<ol>
<li>所有空格、Tab、换行等空白字符，无论在缓冲区开头、中间还是结尾，均会被读取，不忽略。</li>
<li>因为只读取一个字符，所以如果输入多于<code>1</code>个字符（包括换行符），则它们均会残留在缓冲区。具体地说，如果什么字符都不输入，直接按下回车键，则读取到的是换行符<code>\n</code>，缓冲区无任何残留；如果输入一个字符如<code>a</code>，然后按下回车键，则读取到的是字符<code>a</code>，同时换行符<code>\n</code>残留在缓冲区。</li>
</ol>
<p><code>fgetc()</code>和<code>getc()</code>对应的输出函数是<code>fputc()</code>和<code>putc()</code>。</p>
<h4 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h4><p>从<code>stdin</code>读取一个字符。</p>
<p><code>getchar()</code>实际上也由<code>fgetc()</code>宏定义而来，只是默认输入流为<code>stdin</code>。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line">a = getchar();</span><br></pre></td></tr></table></figure>

<p><code>getchar()</code>常常用于清理缓冲区开头残留的换行符。当知道缓冲区开头有<code>\n</code>残留时，可以调用<code>getchar()</code>但不赋值给任何变量，即可实现冲刷掉<code>\n</code>的效果。</p>
<p><code>getchar()</code>对应的输出函数是<code>putchar()</code>。</p>
<h3 id="C-标准输入-1"><a href="#C-标准输入-1" class="headerlink" title="C++ 标准输入"></a>C++ 标准输入</h3><p>C++中使用标准输入输出需要包含头文件<code>&lt;iostream&gt;</code>。一般使用<code>iostream</code>类进行流操作，其封装很完善，也比较复杂，本文只介绍一部分。</p>
<h4 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h4><p><code>cin</code>是 C++ 的标准输入流对象，即<code>istream</code>类的一个对象实例。<code>cin</code>有自己的缓冲区，但默认情况下是与<code>stdin</code>同步的，因此在 C++ 中可以混用 C++ 和 C 风格的输入输出（在不手动取消同步的情况下）。</p>
<p><code>cin</code>与<code>stdin</code>一样是行缓冲，即遇到换行符时才会将数据同步到输入缓冲区。</p>
<p><code>cin</code>的用法非常多，只列举常用的几种。最常用的就是使用<code>&gt;&gt;</code>符号（我认为该符号形象地体现了“流”的特点）。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">cin &gt;&gt; str;</span><br></pre></td></tr></table></figure>

<p><code>cin</code>对空白字符的处理与<code>scanf</code>一致。即：跳过开头空白字符，遇到空白字符停止读取，且空白字符（包括换行符）残留在缓冲区。</p>
<p>如果不想跳过空白字符，可以使用流控制关键词<code>noskipws</code>（no skip white space），但这只对单个字符有效（类似于<code>scanf</code>中的<code>%c</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin &gt;&gt; noskipws &gt;&gt; c;</span><br></pre></td></tr></table></figure>

<p>注意，<code>cin</code>对象属于命名空间<code>std</code>，如果想使用<code>cin</code>对象，必须在 C++ 文件开头写<code>using namespace std</code>，或者在每次用到的时候写成<code>std::cin</code>。</p>
<h4 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h4><p>读取单个或指定长度的字符，包括空白字符。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a, b;</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取一个字符，读取失败时返回0，多余字符残留在缓冲区（包括换行符）</span></span><br><span class="line">a = cin.<span class="built_in">get</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取一个字符，读取失败时返回EOF，多余字符残留在缓冲区（包括换行符）</span></span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在遇到指定终止字符（参数3）前，至多读取n-1个（参数2）字符</span></span><br><span class="line"><span class="comment">// 当不指定终止字符时，默认为换行符\n</span></span><br><span class="line"><span class="comment">// 如果输入的字符个数小于等于n-1（不含终止字符），则终止字符不残留在缓冲区</span></span><br><span class="line"><span class="comment">// 如果输入的字符个数多于n-1（不含终止字符），则余下字符将残留在缓冲区</span></span><br><span class="line">cin.<span class="built_in">get</span>(str, <span class="built_in">sizeof</span>(str), <span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>cin.get()</code>读取单个字符时，类似于 C 中的<code>fgetc()</code>，对空白字符的处理也与其一致。<code>cin.get()</code>读取的字符也可以赋值给整型变量。</p>
<p><code>cin.get()</code>读取指定长度个字符时，类似于 C 中的<code>fgets()</code>，但在换行符的处理上不同。它们都不会使换行符残留在缓冲区，但<code>fgets()</code>会将缓冲区末尾的换行符<code>\n</code>也写入字符串，而<code>cin.get()</code>会丢弃缓冲区末尾的<code>\n</code>。即：当输入<code>test</code>时，用<code>fgets()</code>读取得到的字符串长度为<code>5</code>，用<code>cin.get()</code>读取得到的字符串长度为<code>4</code>。</p>
<h4 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()"></a>cin.getline()</h4><p>读取指定长度的字符，包括空白字符。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(str, <span class="built_in">sizeof</span>(str));    <span class="comment">// 第3个参数也可以指定终止字符</span></span><br></pre></td></tr></table></figure>

<p><code>cin.getline()</code>与<code>cin.get()</code>指定读取长度时的用法几乎一样。区别在于，如果输入的字符个数大于指定的最大长度<code>n-1</code>（不含终止符），<code>cin.get()</code>会使余下字符残留在缓冲区，等待下次读取；而<code>cin.getline()</code>会给输入流设为 Fail 状态，在主动恢复之前，无法再进行正常输入。</p>
<h4 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h4><p><code>getline()</code>并不是标准输入流<code>istream</code>的函数，而是字符串流<code>sstream</code>的函数，<strong>只能</strong>用于读取数据给**<code>string</code>类对象**，使用时也需要包含头文件<code>&lt;string&gt;</code>。</p>
<p>如果使用<code>getline()</code>读取标准输入流的数据，需要显式指定输入流。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin, str);</span><br></pre></td></tr></table></figure>

<p><code>getline()</code>会读取所有空白字符，且缓冲区末尾的换行符会被丢弃，不残留也不写到字符串结尾。同时，由于<code>string</code>对象的空间是动态分配的，所以会一次性将缓冲区读完，不存在读不完残留在缓冲区的问题。</p>
<p>需要注意的是，假如缓冲区开头就是换行符（比如可能是上一次<code>cin</code>残留的），则<code>getline()</code>会直接读取到空字符串并结束，不会给键盘输入的机会。所以这种情况下要注意先清除开头的换行符。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 C 中，建议使用<code>scanf()</code>进行格式化读取，用<code>fgets()</code>读取整行，用<code>fgetc()</code>或<code>getchar()</code>读取单个字符。</p>
<p>在 C++ 中，建议使用<code>cin &gt;&gt;</code>进行格式化读取，而<code>cin.get()</code>、<code>cin.getline</code>、<code>getline(string)</code>有各自的适用情况。</p>
<p>注意<code>fgets()</code>和<code>cin.get()</code>在对换行符的清理方面有所区别。</p>
<h2 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h2><h3 id="C-标准输出"><a href="#C-标准输出" class="headerlink" title="C 标准输出"></a>C 标准输出</h3><h4 id="标准输出流及对缓冲区的理解"><a href="#标准输出流及对缓冲区的理解" class="headerlink" title="标准输出流及对缓冲区的理解"></a>标准输出流及对缓冲区的理解</h4><p>相应于输入流的<code>stdin</code>，输出流也有其默认的文件描述符<code>stdout</code>，对应着命令行终端（Windows 中称为控制台）的显示。此外，还有对应错误输出的<code>stderr</code>，默认也是终端的显示。它们都可以被重定向到文件中以便持久保存和查看，在此不作赘述。</p>
<p><code>stdout</code>也是<strong>行缓冲</strong>I&#x2F;O，它与<code>stdin</code>类似也有三者之间的数据同步：从用户程序到<code>stdout</code>的输出缓冲区，由用户程序决定；从<code>stdout</code>的输出缓冲区到终端的显示，只有缓冲区末尾遇到换行符<code>\n</code>才会进行。如果输出缓冲区末尾没有换行符<code>\n</code>，是不会打印显示输出的。</p>
<p>例如以下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序 2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序 3</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\nABCDE&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序 1 中，<code>printf()</code>输出内容的最后有换行符<code>\n</code>，所以将在屏幕上输出<code>Hello World!</code>并换行，然后进入<code>while(1)</code>循环阻塞住。</p>
<p>程序 2 中，把<code>\n</code>去掉了，此时终端不会显示任何内容。因为程序进入死循环后，没有机会向<code>stdout</code>中写入<code>\n</code>使其清空缓冲。</p>
<p>程序 3 中，虽然没有写入换行符，但是依然能够在终端打印<code>Hello World!</code>（只是没有换行）。这是因为程序结束时会自动清空缓冲区。（除此之外，当缓冲区被填满时也会自动清空）</p>
<p>程序 4 能够进一步加深对<strong>行缓冲</strong>的理解。它在程序 1 的基础上，在换行符之后又加上了几个字符。运行可以发现终端只打印了<code>Hello World!</code>并换行，而没有打印<code>ABCDE</code>。</p>
<p>输出函数通常没有针对对空格、制表符的特殊行为，比输入要简单一些。特殊的处理一般只有换行符。</p>
<h4 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h4><p>按照特定格式将<code>stdout</code>缓冲区的内容打印到终端。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number a = %d&quot;</span>, a);      <span class="comment">// 十进制整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Number b = %.2f&quot;</span>, b);    <span class="comment">// 浮点数，保留两位小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String s = %s&quot;</span>, s);      <span class="comment">// 字符串</span></span><br></pre></td></tr></table></figure>

<p><code>printf()</code>的写法与<code>scanf()</code>十分相像。区别在于<code>scanf()</code>中一般只有格式控制字符，而没有其他普通字符，而<code>printf()</code>中常常是在一串字符中把要替换的内容写为格式控制字符，从而形成格式化输出的效果。</p>
<h4 id="puts"><a href="#puts" class="headerlink" title="puts()"></a>puts()</h4><p>将字符串和一个尾随的换行符<code>\n</code>写入到<code>stdout</code>的缓冲区。根据行缓冲的性质，终端也会立即进行打印显示。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// 立即输出hello并换行</span></span><br></pre></td></tr></table></figure>

<p><code>puts()</code>对换行符的处理与<code>gets()</code>“相反”。<code>gets()</code>会自动丢弃一个换行符，而<code>puts()</code>则是自动写入一个换行符。</p>
<h4 id="fputs"><a href="#fputs" class="headerlink" title="fputs()"></a>fputs()</h4><p>将<strong>字符串</strong>写入指定输出流，可以是文件流、<code>stdout</code>或<code>stderr</code>等。<code>stderr</code>是标准错误流，它是<strong>无缓冲</strong>的，会立即输出到屏幕，而不是等待换行符才输出。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello world&quot;</span>, <span class="built_in">stdout</span>);    <span class="comment">// 不会立即输出</span></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello world\n&quot;</span>, <span class="built_in">stdout</span>);  <span class="comment">// 立即输出</span></span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;hello world&quot;</span>, <span class="built_in">stderr</span>);  <span class="comment">// 立即输出</span></span><br></pre></td></tr></table></figure>

<p>与<code>fgets()</code>一样，<code>fputs()</code>不会主动操作换行符。如果希望立即输出，需要自己加上换行符<code>\n</code>。</p>
<h4 id="fputc-amp-putc"><a href="#fputc-amp-putc" class="headerlink" title="fputc() &amp; putc()"></a>fputc() &amp; putc()</h4><p>将<strong>一个字符</strong>写入指定输出流，可以是文件流、<code>stdout</code>或<code>stderr</code>等。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;q&#x27;</span>;</span><br><span class="line">fputc(c, <span class="built_in">stdout</span>);</span><br><span class="line">c = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">putc(c, <span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>

<p><code>fputc()</code>和<code>putc()</code>只是把字符写入<code>stdout</code>，没有任何额外操作。因此如果希望立即输出，需要自己加上换行符<code>\n</code>。</p>
<h4 id="putchar"><a href="#putchar" class="headerlink" title="putchar()"></a>putchar()</h4><p>将<strong>一个字符</strong>写入到标准输出流<code>stdout</code>。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br></pre></td></tr></table></figure>

<p>同上，<code>putchar()</code>不操作换行符。如果希望立即输出，需要自己加上换行符<code>\n</code>。</p>
<h4 id="fflush"><a href="#fflush" class="headerlink" title="fflush()"></a>fflush()</h4><p>该函数的功能是强制刷新缓冲区，将数据立即写到对应的文件（或设备）。其参数可以是文件流指针，也可以是<code>stdout</code>。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;Hello World!&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>上面的程序在进入死循环前，会输出<code>Hello World!</code>字符串到屏幕。</p>
<blockquote>
<p>注意：不能够将<code>fflush()</code>用于<code>stdin</code>！这可能导致不可预料的后果。</p>
</blockquote>
<h3 id="C-标准输出-1"><a href="#C-标准输出-1" class="headerlink" title="C++ 标准输出"></a>C++ 标准输出</h3><h4 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h4><p><code>cout</code>是<code>ostream</code>类的一个实例。<code>cout</code>是行缓冲的。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>插入<code>endl</code>对象时，将立即清空输出缓冲区并显示，然后输出一个换行符<code>\n</code>。</p>
<p>也有<code>cout.put()</code>等函数，不常用。</p>
<h4 id="cerr"><a href="#cerr" class="headerlink" title="cerr"></a>cerr</h4><p><code>cerr</code>是标准错误流，也是<code>ostream</code>类的一个实例，并默认输出设备为显示屏上的命令行终端。它默认与<code>stderr</code>同步。</p>
<p><code>cerr</code>是<strong>非缓冲</strong>的，即插入数据时会立即输出。</p>
<p><strong>用法示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;File open FAILED!&quot;</span>;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;[Error] &quot;</span> &lt;&lt; str;</span><br></pre></td></tr></table></figure>

<h4 id="clog"><a href="#clog" class="headerlink" title="clog"></a>clog</h4><p><code>clog</code>是标准日志流，也是<code>ostream</code>类的一个实例，并默认输出设备为显示屏上的命令行终端。</p>
<p><code>clog</code>是有缓冲的，但具体的刷新条件没有找到资料。实测以下代码是可以输出在屏幕的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clog &lt;&lt; <span class="string">&quot;Failed!&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>标准输出相比输入来说较为简单。需要注意的是<code>stdout</code>和<code>cout</code>是<strong>行缓冲</strong>的，而<code>stderr</code>和<code>cerr</code>是<strong>无缓冲</strong>的。</p>
<p>C++ 流的高级用法请参考其他资料。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/20/%E5%9C%A8Maven%E4%B8%AD%E5%87%BA%E7%8E%B0javax-mail%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/" rel="prev" title="在Maven中出现javax.mail中文乱码问题解决记录">
      <i class="fa fa-chevron-left"></i> 在Maven中出现javax.mail中文乱码问题解决记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/02/C%E8%AF%AD%E8%A8%80%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E4%B8%AD%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%B9%B6%E8%B5%8B%E5%80%BC%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91/" rel="next" title="C语言条件语句中调用函数并赋值时的一个小坑">
      C语言条件语句中调用函数并赋值时的一个小坑 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">1.</span> <span class="nav-text">标准输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5"><span class="nav-number">1.1.</span> <span class="nav-text">C 标准输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81%E5%8F%8A%E5%AF%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">标准输入流及对缓冲区的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scanf"><span class="nav-number">1.1.2.</span> <span class="nav-text">scanf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gets-%E4%B8%8D%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.1.3.</span> <span class="nav-text">gets() - 不建议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fgets"><span class="nav-number">1.1.4.</span> <span class="nav-text">fgets()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fgetc-amp-getc"><span class="nav-number">1.1.5.</span> <span class="nav-text">fgetc() &amp; getc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getchar"><span class="nav-number">1.1.6.</span> <span class="nav-text">getchar()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5-1"><span class="nav-number">1.2.</span> <span class="nav-text">C++ 标准输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cin"><span class="nav-number">1.2.1.</span> <span class="nav-text">cin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cin-get"><span class="nav-number">1.2.2.</span> <span class="nav-text">cin.get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cin-getline"><span class="nav-number">1.2.3.</span> <span class="nav-text">cin.getline()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getline"><span class="nav-number">1.2.4.</span> <span class="nav-text">getline()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">2.</span> <span class="nav-text">标准输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA"><span class="nav-number">2.1.</span> <span class="nav-text">C 标准输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81%E5%8F%8A%E5%AF%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">2.1.1.</span> <span class="nav-text">标准输出流及对缓冲区的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#printf"><span class="nav-number">2.1.2.</span> <span class="nav-text">printf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#puts"><span class="nav-number">2.1.3.</span> <span class="nav-text">puts()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fputs"><span class="nav-number">2.1.4.</span> <span class="nav-text">fputs()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fputc-amp-putc"><span class="nav-number">2.1.5.</span> <span class="nav-text">fputc() &amp; putc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#putchar"><span class="nav-number">2.1.6.</span> <span class="nav-text">putchar()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fflush"><span class="nav-number">2.1.7.</span> <span class="nav-text">fflush()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA-1"><span class="nav-number">2.2.</span> <span class="nav-text">C++ 标准输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#cout"><span class="nav-number">2.2.1.</span> <span class="nav-text">cout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cerr"><span class="nav-number">2.2.2.</span> <span class="nav-text">cerr</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clog"><span class="nav-number">2.2.3.</span> <span class="nav-text">clog</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MidoQ"
      src="/images/avatar-qmf.png">
  <p class="site-author-name" itemprop="name">MidoQ</p>
  <div class="site-description" itemprop="description">钱缪峰的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/MidoQ" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MidoQ" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:qmfeng@seu.edu.cn" title="E-Mail → mailto:qmfeng@seu.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MidoQ</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'pHkGJsNXBe2ezFAKXvqJPDqz-gzGzoHsz',
      appKey     : 'QbnOPXmD1ULkk3AYPktpOCvD',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
